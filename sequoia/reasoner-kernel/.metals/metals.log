2024.06.19 17:42:56 INFO  Started: Metals version 1.3.1 in folders '/home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel' for client Visual Studio Code 1.90.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@2dc24eb0]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@45ad2714]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@2dc24eb0]
2024.06.19 17:42:56 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
Jun 19, 2024 5:42:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextRunnable.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package com.sequoiareasoner.kernel.context\n\nimport com.sequoiareasoner.kernel.clauses._\nimport com.sequoiareasoner.kernel.index._\nimport com.sequoiareasoner.kernel.structural.DLOntology\nimport com.sequoiareasoner.arrayops._\nimport com.sequoiareasoner.kernel.logging.DerivationObserver\nimport com.sequoiareasoner.kernel.owl.iri.IRI\n\nimport scala.language.postfixOps\nimport com.sequoiareasoner.kernel.context.RuleSaturator._\nimport com.sequoiareasoner.kernel.context.ClausePusher._\nimport com.sequoiareasoner.kernel.context.inferenceRule._\n\nimport java.util.concurrent.Callable\n\nclass ContextRunnable(\n    val state: ContextState,\n    val ontology: DLOntology,\n    val isEqualityReasoningEnabled: Boolean,\n    val order: ContextLiteralOrdering,\n    val contextStructureManager: ContextStructureManager) {\n    /** Step 1: apply the Core rule */\n    if (state.core.exists( p \u003d\u003e ontology.isNothing(p) )) {\n      state.processCandidateConclusion(ContextClause(ArrayBuilders.emptyPredicateArray, ArrayBuilders.emptyLiteralArray)(order), inferenceRule.Core)\n      if (state.isNominalContext) {\n        System.out.println(\"WARNING: Inconsistent Ontology!\")\n        contextStructureManager.interrupt()\n      }\n    }\n    else {\n      for (p \u003c- state.core) {\n        val fired \u003d state.processCandidateConclusion(ContextClause(ArrayBuilders.emptyPredicateArray, Array(p))(order), inferenceRule.Core)\n        /** For debugging: */\n        if (fired \u0026\u0026 state.isSelectedCore()) DerivationObserver.coreFired(state.core,p)\n      }\n    }\n\n    /** Step 2: apply Hyper rule on clauses from the ontology with an empty body.  Since the body is empty,\n      *  the head cannot contain any neighbour variables. */\n    for (OntologyClause(body, head) \u003c- ontology.getNonGroundClausesWithEmptyBody) {\n      if (state.hornPhaseActive \u0026\u0026 head.length \u003e 1) {}\n      else {\n        val fired \u003d state.processCandidateConclusion(ContextClause(ArrayBuilders.emptyPredicateArray, head)(order), inferenceRule.Hyper)\n        /** For debugging: */\n        if (fired \u0026\u0026 state.isSelectedCore()) DerivationObserver.hyperFired(state.core, OntologyClause(body, head), new IdentitySubstitution,\n          Seq.empty[ContextClause], ContextClause(ArrayBuilders.emptyPredicateArray, head)(order)) // DEBUG\n      }\n    }\n\n    /** Step 3: perform all remaining inferences */\n    def saturateAndPush(): Callable[Unit] \u003d () \u003d\u003e {\n      Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager, this, state.hornPhaseActive)\n    }\n\n\n    /** Step 4: Separated into a separate method - receive a message and start a new saturation round */\n    def reSaturateUponMessage(message: InterContextMessage): Unit \u003d this.synchronized {\n      message match {\n        case StartNonHornPhase() \u003d\u003e {\n          /** When the Horn Phase optimisation is activated, this message reactivates contexts and kickstarts the non-Horn phase */\n          state.hornPhaseActive \u003d false\n\n          /** Step 0 and 1 should have been done already */\n          for (OntologyClause(body, head) \u003c- ontology.getNonGroundClausesWithEmptyBody if head.length \u003e 1) {\n            val fired \u003d state.processCandidateConclusion(ContextClause(ArrayBuilders.emptyPredicateArray, head)(order), inferenceRule.Hyper)\n            /** For debugging: */\n            if (fired \u0026\u0026 state.isSelectedCore()) DerivationObserver.hyperFired(state.core, OntologyClause(body, head), new IdentitySubstitution,\n              Seq.empty[ContextClause], ContextClause(ArrayBuilders.emptyPredicateArray, head)(order))\n          }\n\n          /** We directly saturate; new clauses added in the step just above, and old, non-Horn ones in the todo.nonHornUnprocessed should now be processed */\n          Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager, this, state.hornPhaseActive)\n        }\n\n\n        /** Message received: SuccPush - a clause pushed from a predecessor context.  */\n        case SuccPush(contextChannel: ContextRunnable,\n        edgeLabel: Term,\n        predicate: Predicate, parentCore: ImmutableSet[Predicate]) \u003d\u003e\n          //if (state.isSelectedCore2() \u0026\u0026 state.isSelectedPredicate(predicate) \u0026\u0026 state.isSelectedCore(parentCore)) {\n          //System.out.println(\"[Physiological] Received succ predicate: \" + predicate + \" from context with core \" + parentCore + \" connected by edge with label \" + edgeLabel)\n          //  System.out.println(\"Now attempting to see if this unblocks blocked clauses\")\n          // }\n          /** This is awful! It looks like we define a value, but actually this might unblock pred\n            *  clauses already in the context and process them, adding them to todo */\n          val hasUnblocked \u003d state.addContextStructurePredecessor(contextChannel, edgeLabel, predicate, parentCore)\n          // if (state.isSelectedCore2() \u0026\u0026 state.isSelectedPredicate(predicate) \u0026\u0026 state.isSelectedCore(parentCore)) System.out.println(\"And the answer is: \" + hasUnblocked)\n          // Succ rule conclusion generation\n          val fired \u003d state.processCandidateConclusion(ContextClause(Array(predicate), Array(predicate))(order), inferenceRule.Succ)\n          // if (clauseAdded \u0026\u0026 state.isSelectedCore2() \u0026\u0026 state.isSelectedClause(ContextClause(Array(predicate),Array(predicate))(order)))\n          //  System.out.println(\"[Physiological] Derived clause: \" + ContextClause(Array(predicate),Array(predicate))(order))\n          if (fired \u0026\u0026 state.isSelectedCore()) DerivationObserver.succFired(state.core, ContextClause(Array(predicate), Array(predicate))(order))\n          if (!fired) {\n            /** This optimisation is tricky as F*CK.\n              * TL;DR We need to pushWorkedOffPredClauses here always; however, if !fired, we can guarantee that pushing off\n              * these clauses is unnecessary.\n              * Whenever we add a new edge from a predecessor to this context with\n              * mention that a predicate A appears in a maximal position in a clause, we want to ensure that all applications\n              * of Pred that involve this edge and this predicate are performed. To ensure this, we need to ensure 1) that all pred clauses\n              * that already mention this predicate in the body are propagated back to the predecessor context. This includes\n              * all current workedoff pred clauses with explicitly A in the body, if A is not part of the core of current context, or ALL workedoff\n              * pred clauses if A is part of the core of the current context (because implicitly is in the body), and 2)\n              * in the future, if we derive a clause with head purely of predTriggers that has A in the body, it will automatically be\n              * propagated to the predecessor context. 2) Is ensured because of how candidate consequences are processed. 1) can be ensured by\n              * propagating workedOffClauses. HOWEVER, if A -\u003e A has been added, this is a guarantee that A IS NOT PART OF THE CORE,\n              * AND THERE WAS NO CLAUSE WITH A IN THE BODY BEFORE, because any A in the body appears only via A -\u003e A. This\n              * ensures that propagating workedofff clauses at this point would be irrelevant, because none of them would match the required\n              * condition.\n              *\n              * Incidentally, this is what Andrew said: Push the worked off pred clauses first before\n              * pushPredClausesDerivedInLastRound to avoid repetition.\n              * Doesn\u0027t seem to be avoid repetition here, but just skipping an unnecessary step.\n               */\n            // if (state.isSelectedCore2() \u0026\u0026 state.isSelectedPredicate(predicate) \u0026\u0026 state.isSelectedCore(parentCore))\n            //  System.out.println(\"[Physiological] Attempting to push worked off pred clauses to context with core\" + parentCore + \" across edge \" + edgeLabel + \"containing predicate \" + predicate)\n            pushWorkedOffPredClauses(state, contextStructureManager, contextChannel, edgeLabel, predicate, parentCore)\n          }\n          if (fired || hasUnblocked) {\n            Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager, this, state.hornPhaseActive)\n          }\n\n        /** Message received: PredPush - a clause pushed from a successor, which can be resolved with clauses in this\n          * context. */\n        case PredPush(edgeLabel: Term, neighbourCore: ImmutableSet[Predicate],\n        predClauses: IndexedSequence[ContextClause]) \u003d\u003e\n          predClauses foreach { clause \u003d\u003e\n            /** Generate corresponding PredClause after doing substitution */\n            val nominalCore \u003d if (state.isNominalContext) Some(state.core.toSeq.head.asInstanceOf[Concept].iri.uid) else None\n  //          if (state.isSelectedCore() )  System.out.println(\"Received clause: \" + clause + \" from context with core \" + neighbourCore)\n            val predClause: PredClause \u003d state.neighborIndex.transformAndAdd(edgeLabel, neighbourCore, nominalCore, clause)\n  //          if (state.isSelectedCore() )  System.out.println(\"Transformed clause to: \" + predClause)\n            Rules.Pred(state.workedOffClauses.maxHeadPredicateLookup, predClause, order, state.resultsBuffer)\n            Context.processResultsBuffer(state,Pred)\n          }\n          Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order,\n            contextStructureManager, this, state.hornPhaseActive)\n\n        case QueryPush(nominal: Constant, queryClauses: IndexedSequence[ContextClause]) \u003d\u003e\n          queryClauses foreach { clause \u003d\u003e\n //           if (state.isSelectedCore()) System.out.println(\"Received Query Push : \" + clause) // DEBUG\n            val queryClause: PredClause \u003d state.neighborIndex.transformQueryHeadAndAdd(nominal, clause)\n //           if (state.isSelectedCore()) println(\"Transformed version of this clause: \" + queryClause)\n            Rules.Close(state.workedOffClauses.maxHeadEqualityLookup, state.workedOffClauses.maxHeadPredicateLookup,\n              state.getUnaryCoreConcept.iri, queryClause, nominal, order, state.resultsBuffer)\n            Context.processResultsBuffer(state,Query)\n          }\n          Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager,\n            this, state.hornPhaseActive)\n\n        /** Message received: A(o) -\u003e A(o) from a predecessor context.  */\n        case PossibleGroundFactPush(contextChannel: ContextRunnable, edgeLabel: Term,\n        predicate: Predicate) \u003d\u003e\n          predicate match {\n            /** Let us exclude propagations of type conceptFor:a(a), since these may not always be prevented by the optimisation,\n            * and are always unnecessary */\n            case Concept(iri, v) if iri.isInternalIndividual \u0026\u0026\n              (Term(IRI.nominalConceptUid2NominalIriStringName(iri.uid)) \u003d\u003d v) \u003d\u003e\n            case _ \u003d\u003e\n              /** Predicate has not been transformed, it is a ground fact C(o); we store this in the predecessor index */\n              val hasUnblocked \u003d state.addContextStructurePredecessor(contextChannel, edgeLabel, predicate)\n              /** If this is a nominal context with core conceptFor:o, and the predicate contains\n                *  the constant o, we then replace it by x */\n              val transformedPredicate \u003d if (!state.isNominalContext) predicate else predicate match {\n                case Concept(iri, v) if v \u003d\u003d Term(IRI.nominalConceptUid2NominalIriStringName(state.getCoreConcept.iri.uid))\n                \u003d\u003e Concept(iri, CentralVariable)(ontology)\n                case _ \u003d\u003e predicate\n              }\n              val clauseAdded \u003d state.processCandidateConclusion(ContextClause(Array(transformedPredicate),\n                Array(transformedPredicate))(order), inferenceRule.Succ)\n              if (clauseAdded \u0026\u0026 state.isSelectedCore()) DerivationObserver.allSuccFired(state.core,\n                ContextClause(Array(transformedPredicate), Array(transformedPredicate))(order))\n              if (!clauseAdded) {\n                pushWorkedOffPredClauses(state, contextStructureManager, contextChannel, edgeLabel, transformedPredicate)\n              }\n              if (clauseAdded || hasUnblocked) {\n                Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager,\n                  this, state.hornPhaseActive)\n              }\n          }\n\n         /** If a potential collapse to a nominal `o` is detected in a query context with core A(x), we push the\n            * clause A(x) -\u003e A(x) to the corresponding nominal context for `o`, and add an edge labelled `A(x)` from\n            * that query context, to the nominal context for `o`. This is the detection of such push in a nominal context. */\n        case CollPush(contextChannel: ContextRunnable, edgeLabel: Predicate) \u003d\u003e {\n          state match {\n            case nomState: NominalContextState \u003d\u003e {\n              /** The corresponding root predecessor is added */\n              nomState.addRootPredecessor(contextChannel, edgeLabel)\n              /** We consider the addition of the relevant clause A(x) -\u003e A(x) */\n              val clauseAdded \u003d state.processCandidateConclusion(ContextClause(Array(edgeLabel), Array(edgeLabel))(order), inferenceRule.Coll)\n              /** If the clause is added, we need to update indices and start round */\n              if (clauseAdded) {\n                if (state.isSelectedCore()) DerivationObserver.eqSuccFired(state.core, ContextClause(Array(edgeLabel), Array(edgeLabel))(order)) //DEBUG\n                Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager, this, state.hornPhaseActive)\n              } else {\n              /** If no clause is added, we need to see if we can propagate anything back, except if certain fact, which does not propagate */\n                pushWorkedOffQueryClauses(nomState, contextStructureManager, contextChannel, edgeLabel)\n              }\n            }\n            case _ \u003d\u003e\n          }\n        }\n\n        case CGCPush(clause,originCore) \u003d\u003e {\n          // if (state.isSelectedCore()) {println(\"CGC clause pushed!\"); println(clause)}\n          /** If we are in a nominal context with core O(x), we replace any mention of o in the input clause by x */\n          val processedClause \u003d if (state.isNominalContext) {\n            val nominal \u003d Term(IRI.nominalConceptUid2NominalIriStringName(state.getCoreConcept.iri.uid))\n            val sigma \u003d new NominalAbstractionSubstitution(nominal)\n            clause.applySubstitution(sigma)\n          } else clause\n          val clauseAdded \u003d state.processCandidateConclusion(processedClause, CertainGroundClause)\n          if (clauseAdded) {\n            if (state.isSelectedCore())  DerivationObserver.cgcFired(state.core,clause,originCore)\n            Context.saturateAndPush(state, ontology, isEqualityReasoningEnabled, order, contextStructureManager, this, state.hornPhaseActive)\n          }\n        }\n\n        /** We are a nominal context and receive a message from some other context: ``I mention your constant\u0027\u0027,\n          * so we add the context to the relevant list and propagate all existing certain ground clauses. */\n        case ConstantMentionedPush(originContext) \u003d\u003e {\n         // if (state.isSelectedCore()) println(\"Received mentioned constant push in context with core \" + state.getCoreConcept)\n          state match {\n            case nomState: NominalContextState \u003d\u003e {\n              nomState.constantPredecessors.add(originContext)\n              pushWorkedOffCertainGroundClauses(nomState,contextStructureManager,originContext,ontology)\n            }\n            case _ \u003d\u003e\n          }\n        }\n\n        case ConstantExchange(originContext,coreConstant) \u003d\u003e {\n          /** If the constant corresponding to the core of the origin constant has not been mentioned yet,\n            * we update the set of mentioned constants, and send a request to `originContext` to send all\n            * relevant CGCs */\n       //   if (state.isSelectedCore()) println(\"Received constant exchange message from nominal context for \" + coreConstant)\n          state match {\n            /** Optimisation: if target and core contexts are the same, just do nothing */\n            case nomState: NominalContextState if nomState.getCoreConstant.id \u003d\u003d coreConstant.id \u003d\u003e\n            case _ \u003d\u003e {\n              if (state.addConstantToMentionedConstantSet(coreConstant)) {\n                contextStructureManager.messageContext(originContext, ConstantMentionedPush(this))\n              }\n            }\n          }\n        }\n      }\n    }\n}"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextRunnable.scala
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.MetalsLspService.didOpen(MetalsLspService.scala:1123)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:376)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more

Jun 19, 2024 5:42:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala",
      "languageId": "scala",
      "version": 786,
      "text": "package com.sequoiareasoner.kernel.context\n\nimport akka.actor.ActorRef\nimport akka.actor.ActorSystem\nimport akka.actor.Props\nimport akka.actor.UntypedActor\n\nimport java.util.Collections\nimport java.util.List\nimport java.util.concurrent.AbstractExecutorService\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.TimeUnit\nimport java.util.function.Function\nimport java.util.concurrent.ForkJoinPool\n\n\n// class ActorDemo {\n\n//     public static void main( String[] args ) throws InterruptedException {\n//         // The following partitioner will spread the requests over\n//         // multiple actors, which I chose to demonstrate the technique.\n//         // You will need to change it to one that better maps the the\n//         // jobs to your use case.   Remember that jobs that get mapped\n//         // to the same key, will get executed in serial (probably\n//         // but not necessarily) by the same thread.\n//         ExecutorService exectorService \u003d new ActorExecutionService( job -\u003e job.hashCode()+\"\" );\n\n//         for ( int i\u003d0; i\u003c100; i++ ) {\n//             int id \u003d i;\n//             exectorService.submit( () -\u003e System.out.println(\"JOB \" + id) );\n//         }\n\n//         exectorService.shutdown();\n//         exectorService.awaitTermination( 1, TimeUnit.MINUTES );\n\n//         System.out.println( \"DONE\" );\n//     }\n\n// }\n\n\nclass ActorExecutionService extends ForkJoinPool {\n    val actorSystem: ActorSystem \u003d ActorSystem.create(\"context-actor-system\")\n    val actors: ConcurrentHashMap[String,ActorRef] \u003d new ConcurrentHashMap()\n\n    def executeWithPartition(command: Runnable, partitionKey: String): Unit \u003d {\n        val actorRef: ActorRef \u003d actors.computeIfAbsent(partitionKey, createNewActor(_))\n        actorRef.tell(command, actorRef)\n    }\n\n    private def createNewActor(partitionKey: String): ActorRef \u003d {\n        return actorSystem.actorOf(Props.create(classOf[ExecutionServiceActor]), partitionKey)\n    }\n\n\n    // def shutdown(): Unit \u003d {\n    //     actorSystem.terminate()\n    // }\n\n    // def shutdownNow(): List[Runnable] \u003d {\n    //     actorSystem.terminate()\n\n    //     try {\n    //         awaitTermination( 1, TimeUnit.MINUTES )\n    //     } catch {\n    //         case e: InterruptedException \u003d\u003e throw new RuntimeException(e)\n    //     }\n\n    //     return Collections.emptyList()\n    // }\n\n    // def isShutdown(): Boolean \u003d {\n    //     return actorSystem.isTerminated()\n    // }\n\n    // def isTerminated(): Boolean \u003d {\n    //     return actorSystem.isTerminated()\n    // }\n\n    // def awaitTermination(timeout: Long, unit: TimeUnit): Boolean \u003d {\n    //     actorSystem.awaitTermination()\n\n    //     return actorSystem.isTerminated()\n    // }\n}\n\n class ExecutionServiceActor extends UntypedActor {\n    def onReceive(message: Any): Unit \u003d message match {\n        case runnable: Runnable \u003d\u003e runnable.run()\n        case _ \u003d\u003e throw new Exception(message.toString())\n    }\n}"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.MetalsLspService.didOpen(MetalsLspService.scala:1123)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:376)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more

2024.06.19 17:42:57 INFO  no build target found for /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.06.19 17:42:57 INFO  no build target found for /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.06.19 17:42:57 INFO  no build target found for /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextRunnable.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.06.19 17:42:57 INFO  Running List(/home/pigeon/.local/share/coursier/bin/scala-cli, setup-ide, /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel)
2024.06.19 17:42:57 INFO  Attempting to connect to the build server...
2024.06.19 17:42:57 INFO  Running BSP server List(/home/pigeon/.local/share/coursier/bin/.scala-cli.aux, bsp, --json-options, /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/.scala-build/ide-options-v2.json, --json-launcher-options, /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/.scala-build/ide-launcher-options.json, --envs-file, /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/.scala-build/ide-envs.json, /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel)
2024.06.19 17:42:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/.metals/bsp.trace.json or /home/pigeon/.cache/metals/bsp.trace.json
Jun 19, 2024 5:42:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.nio.file.NoSuchFileException: /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala
java.util.concurrent.CompletionException: java.nio.file.NoSuchFileException: /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.nio.file.NoSuchFileException: /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:410)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionAbsolutePathBuffers.toInputFromBuffers(MetalsEnrichments.scala:603)
	at scala.meta.internal.metals.SourceMapper.input$1(SourceMapper.scala:30)
	at scala.meta.internal.metals.SourceMapper.$anonfun$pcMapping$2(SourceMapper.scala:35)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.SourceMapper.default$1(SourceMapper.scala:35)
	at scala.meta.internal.metals.SourceMapper.$anonfun$pcMapping$5(SourceMapper.scala:52)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.SourceMapper.pcMapping(SourceMapper.scala:52)
	at scala.meta.internal.metals.Compilers.sourceAdjustments(Compilers.scala:1165)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$2(Compilers.scala:405)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:401)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1659)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.06.19 17:42:57 INFO  no build target found for /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextThreadPool.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.06.19 17:42:58 INFO  no build target found for /home/pigeon/Downloads/msc/MSc-Project/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.06.19 17:42:57 INFO  time: Connected to build server in 0.75s
2024.06.19 17:42:57 INFO  Connected to Build server: scala-cli v1.3.2
2024.06.19 17:42:58 INFO  compiling reasoner-kernel_f4dd477a3a (67 scala sources)
2024.06.19 17:43:02 INFO  time: compiled reasoner-kernel_f4dd477a3a in 3.17s
2024.06.19 17:43:02 INFO  compiling reasoner-kernel_f4dd477a3a (67 scala sources)
2024.06.19 17:43:03 INFO  time: indexed workspace in 4.32s
2024.06.19 17:43:05 INFO  time: compiled reasoner-kernel_f4dd477a3a in 3.58s
2024.06.19 17:43:15 INFO  compiling reasoner-kernel_f4dd477a3a (67 scala sources)
2024.06.19 17:43:17 INFO  time: compiled reasoner-kernel_f4dd477a3a in 1.78s
2024.06.19 17:43:17 INFO  compiling reasoner-kernel_f4dd477a3a (67 scala sources)
